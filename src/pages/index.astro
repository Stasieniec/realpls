---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import UploadArea from '../components/UploadArea.astro';
import ReportView from '../components/ReportView.astro';
---

<Layout title="real pls — image authenticity checks">
  <Header />
  
  <main class="main container">
    <!-- Hero Section (shown before upload) -->
    <section class="hero" id="hero-section">
      <div class="hero-content">
        <h1 class="hero-title">image authenticity checks</h1>
        <p class="hero-subtitle">
          analyze images locally in your browser. no uploads, no tracking.
        </p>
      </div>
      
      <UploadArea />
    </section>
    
    <!-- Report Section (shown after upload) -->
    <section class="report-section" id="report-section">
      <ReportView />
    </section>
  </main>
  
  <Footer />
</Layout>

<script>
  import { 
    loadImage, 
    runForensicPipeline, 
    exportReportJSON, 
    getStatusMessage,
    formatFileSize,
    type ForensicReport,
    type CheckResult,
    type ImageFile
  } from '../lib/forensics';
  
  // DOM Elements
  const heroSection = document.getElementById('hero-section')!;
  const reportSection = document.getElementById('report-section')!;
  const reportView = document.getElementById('report-view')!;
  const uploadArea = document.getElementById('upload-area')!;
  const uploadContent = uploadArea.querySelector('.upload-content')!;
  const uploadLoading = document.getElementById('upload-loading')!;
  const fileInput = document.getElementById('file-input') as HTMLInputElement;
  const demoButton = document.getElementById('demo-button')!;
  const resetButton = document.getElementById('reset-button')!;
  const downloadButton = document.getElementById('download-button')!;
  
  // Report elements
  const summaryBanner = document.getElementById('summary-banner')!;
  const summaryTitle = document.getElementById('summary-title')!;
  const summarySubtitle = document.getElementById('summary-subtitle')!;
  const summaryStats = document.getElementById('summary-stats')!;
  const analysisProgress = document.getElementById('analysis-progress')!;
  const progressFill = document.getElementById('progress-fill')!;
  const progressText = document.getElementById('progress-text')!;
  const reportContent = document.getElementById('report-content')!;
  const previewImage = document.getElementById('preview-image') as HTMLImageElement;
  const overlayCanvas = document.getElementById('overlay-canvas') as HTMLCanvasElement;
  const filename = document.getElementById('filename')!;
  const fileMeta = document.getElementById('file-meta')!;
  const overlayControls = document.getElementById('overlay-controls')!;
  const overlaySelect = document.getElementById('overlay-select') as HTMLSelectElement;
  const opacitySlider = document.getElementById('opacity-slider') as HTMLInputElement;
  const tabContent = document.getElementById('tab-content')!;
  
  // State
  let currentReport: ForensicReport | null = null;
  let currentImageFile: ImageFile | null = null;
  let overlays: Map<string, ImageData> = new Map();
  
  // Tab handling
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => {
        t.classList.remove('active');
        t.setAttribute('aria-selected', 'false');
      });
      tab.classList.add('active');
      tab.setAttribute('aria-selected', 'true');
      
      const tabName = tab.getAttribute('data-tab')!;
      renderTabContent(tabName);
    });
  });
  
  // Drag and drop
  uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
  });
  
  uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
  });
  
  uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    
    const files = e.dataTransfer?.files;
    if (files && files.length > 0) {
      handleFile(files[0]);
    }
  });
  
  // File input
  fileInput.addEventListener('change', () => {
    if (fileInput.files && fileInput.files.length > 0) {
      handleFile(fileInput.files[0]);
    }
  });
  
  // Demo button
  demoButton.addEventListener('click', async (e) => {
    e.stopPropagation();
    try {
      const response = await fetch('/demo/sample.jpg');
      const blob = await response.blob();
      const file = new File([blob], 'demo-image.jpg', { type: 'image/jpeg' });
      handleFile(file);
    } catch (error) {
      console.error('Failed to load demo image:', error);
      alert('Failed to load demo image. Please try uploading your own image.');
    }
  });
  
  // Reset button
  resetButton.addEventListener('click', () => {
    resetView();
  });
  
  // Download button
  downloadButton.addEventListener('click', () => {
    if (currentReport) {
      const json = exportReportJSON(currentReport);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `report-${currentReport.filename}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }
  });
  
  // Overlay controls
  overlaySelect.addEventListener('change', () => {
    updateOverlay();
  });
  
  opacitySlider.addEventListener('input', () => {
    updateOverlay();
  });
  
  // Handle file upload
  async function handleFile(file: File) {
    // Validate file size
    if (file.size > 50 * 1024 * 1024) {
      alert('File too large. Maximum size is 50MB.');
      return;
    }
    
    // Show loading
    uploadContent.classList.add('hidden');
    uploadLoading.classList.remove('hidden');
    
    try {
      // Load image
      currentImageFile = await loadImage(file);
      
      // Show report view
      heroSection.classList.add('hidden');
      reportView.classList.remove('hidden');
      reportContent.classList.add('hidden');
      analysisProgress.classList.remove('hidden');
      
      // Set preview
      previewImage.src = currentImageFile.dataUrl;
      filename.textContent = file.name;
      fileMeta.textContent = `${currentImageFile.width}×${currentImageFile.height} · ${formatFileSize(file.size)}`;
      
      // Run analysis
      currentReport = await runForensicPipeline(currentImageFile, {
        onProgress: (stage, progress) => {
          progressFill.style.width = `${progress}%`;
          progressText.textContent = stage.toLowerCase();
        }
      });
      
      // Hide progress, show content
      analysisProgress.classList.add('hidden');
      reportContent.classList.remove('hidden');
      
      // Update summary
      updateSummary();
      
      // Collect overlays
      collectOverlays();
      
      // Render initial tab
      renderTabContent('overview');
      
    } catch (error) {
      console.error('Analysis failed:', error);
      alert(`Failed to analyze image: ${error instanceof Error ? error.message : 'Unknown error'}`);
      resetView();
    }
  }
  
  function resetView() {
    heroSection.classList.remove('hidden');
    reportView.classList.add('hidden');
    uploadContent.classList.remove('hidden');
    uploadLoading.classList.add('hidden');
    fileInput.value = '';
    currentReport = null;
    currentImageFile = null;
    overlays.clear();
    overlaySelect.innerHTML = '<option value="none">none</option>';
    overlayCanvas.classList.add('hidden');
    overlayControls.classList.add('hidden');
  }
  
  function updateSummary() {
    if (!currentReport) return;
    
    const { overallStatus, summary } = currentReport;
    
    // Update banner class
    summaryBanner.className = `summary-banner status-${overallStatus}`;
    
    // Update text
    summaryTitle.textContent = getStatusMessage(overallStatus).toLowerCase();
    summarySubtitle.textContent = `${currentReport.checks.length} checks completed`;
    
    // Update stats
    summaryStats.innerHTML = `
      <div class="stat-item">
        <div class="stat-value" style="color: var(--color-ok)">${summary.okCount}</div>
        <div class="stat-label">ok</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" style="color: var(--color-warn)">${summary.warnCount}</div>
        <div class="stat-label">warn</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" style="color: var(--color-info)">${summary.infoCount}</div>
        <div class="stat-label">info</div>
      </div>
    `;
  }
  
  function collectOverlays() {
    if (!currentReport) return;
    
    overlays.clear();
    
    for (const check of currentReport.checks) {
      if (check.overlay) {
        overlays.set(check.id, check.overlay);
      }
    }
    
    // Update select options
    overlaySelect.innerHTML = '<option value="none">none</option>';
    
    const overlayNames: Record<string, string> = {
      'noise-consistency': 'noise map',
      'edge-consistency': 'edge map',
      'ela': 'error level analysis',
    };
    
    for (const [id] of overlays) {
      const option = document.createElement('option');
      option.value = id;
      option.textContent = overlayNames[id] || id;
      overlaySelect.appendChild(option);
    }
    
    if (overlays.size > 0) {
      overlayControls.classList.remove('hidden');
    }
  }
  
  function updateOverlay() {
    const selected = overlaySelect.value;
    const opacity = parseInt(opacitySlider.value) / 100;
    
    if (selected === 'none' || !overlays.has(selected)) {
      overlayCanvas.classList.add('hidden');
      return;
    }
    
    const overlayData = overlays.get(selected)!;
    
    // Resize canvas to match image display size
    const imageRect = previewImage.getBoundingClientRect();
    
    overlayCanvas.width = overlayData.width;
    overlayCanvas.height = overlayData.height;
    overlayCanvas.style.width = `${imageRect.width}px`;
    overlayCanvas.style.height = `${imageRect.height}px`;
    overlayCanvas.style.opacity = String(opacity);
    
    const ctx = overlayCanvas.getContext('2d')!;
    ctx.putImageData(overlayData, 0, 0);
    
    overlayCanvas.classList.remove('hidden');
  }
  
  function renderTabContent(tabName: string) {
    if (!currentReport) return;
    
    const checks = currentReport.checks;
    
    switch (tabName) {
      case 'overview':
        renderOverviewTab(checks);
        break;
      case 'metadata':
        renderMetadataTab(checks);
        break;
      case 'forensics':
        renderForensicsTab(checks);
        break;
      case 'visualize':
        renderVisualizeTab(checks);
        break;
    }
  }
  
  function renderOverviewTab(checks: CheckResult[]) {
    const warnings = checks.filter(c => c.status === 'warn');
    const infos = checks.filter(c => c.status === 'info');
    const oks = checks.filter(c => c.status === 'ok');
    
    let html = '';
    
    if (warnings.length > 0) {
      html += `<h4 class="section-title">warnings (${warnings.length})</h4>`;
      warnings.forEach(check => {
        html += renderCheckCard(check);
      });
    }
    
    if (infos.length > 0) {
      html += `<h4 class="section-title" style="margin-top: var(--space-6);">info (${infos.length})</h4>`;
      infos.forEach(check => {
        html += renderCheckCard(check);
      });
    }
    
    if (oks.length > 0) {
      html += `<h4 class="section-title" style="margin-top: var(--space-6);">passed (${oks.length})</h4>`;
      oks.forEach(check => {
        html += renderCheckCard(check);
      });
    }
    
    tabContent.innerHTML = html;
    attachCheckCardListeners();
  }
  
  function renderMetadataTab(checks: CheckResult[]) {
    const metadataChecks = checks.filter(c => 
      ['exif-presence', 'editing-software', 'file-type', 'file-properties', 'animation'].includes(c.id)
    );
    
    if (metadataChecks.length === 0) {
      tabContent.innerHTML = renderEmptyState('no metadata checks available');
      return;
    }
    
    let html = '';
    metadataChecks.forEach(check => {
      html += renderCheckCard(check, true);
    });
    
    tabContent.innerHTML = html;
    attachCheckCardListeners();
  }
  
  function renderForensicsTab(checks: CheckResult[]) {
    const forensicChecks = checks.filter(c => 
      ['jpeg-quality', 'double-compression', 'uniform-areas', 'noise-consistency', 
       'edge-consistency', 'clone-detection', 'ela', 'social-media-hint'].includes(c.id)
    );
    
    if (forensicChecks.length === 0) {
      tabContent.innerHTML = renderEmptyState('no forensic checks available');
      return;
    }
    
    let html = '';
    forensicChecks.forEach(check => {
      html += renderCheckCard(check, true);
    });
    
    tabContent.innerHTML = html;
    attachCheckCardListeners();
  }
  
  function renderVisualizeTab(checks: CheckResult[]) {
    const visualChecks = checks.filter(c => c.overlay);
    
    let html = `
      <div style="margin-bottom: var(--space-4);">
        <p style="color: var(--color-text-muted); font-size: var(--text-sm);">
          use the overlay controls below the image to visualize analysis results.
        </p>
      </div>
    `;
    
    if (visualChecks.length === 0) {
      html += `<div class="empty-state"><p>no overlays available</p></div>`;
    } else {
      html += `<h4 class="section-title">available overlays</h4>`;
      visualChecks.forEach(check => {
        html += renderCheckCard(check);
      });
    }
    
    tabContent.innerHTML = html;
    attachCheckCardListeners();
  }
  
  function renderCheckCard(check: CheckResult, expanded = false): string {
    const statusColors = {
      ok: 'var(--color-ok)',
      warn: 'var(--color-warn)',
      fail: 'var(--color-fail)',
      info: 'var(--color-info)',
    };
    
    const statusLabels = {
      ok: 'ok',
      warn: 'warn',
      fail: 'fail',
      info: 'info',
    };
    
    const detailsHtml = Object.entries(check.details)
      .map(([key, value]) => `
        <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--color-border);">
          <span style="color: var(--color-text-muted); font-size: 13px;">${key}</span>
          <span style="font-family: var(--font-mono); font-size: 13px; color: var(--color-text-secondary);">${value ?? '—'}</span>
        </div>
      `).join('');
    
    return `
      <div class="check-card ${expanded ? 'expanded' : ''}">
        <div class="check-header" tabindex="0" role="button" aria-expanded="${expanded}">
          <span class="check-badge" style="color: ${statusColors[check.status]}; font-size: 11px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em;">${statusLabels[check.status]}</span>
          <div class="check-info">
            <div class="check-name">${check.name.toLowerCase()}</div>
            <div class="check-summary">${check.summary.toLowerCase()}</div>
          </div>
          <svg class="check-expand" width="12" height="12" viewBox="0 0 12 12" fill="none">
            <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="check-details">
          ${detailsHtml}
          <div class="confidence-bar">
            <label>confidence</label>
            <div class="confidence-track">
              <div class="confidence-fill" style="width: ${check.confidence * 100}%"></div>
            </div>
            <span class="confidence-value">${Math.round(check.confidence * 100)}%</span>
          </div>
          ${check.notes ? `<div class="check-notes">${check.notes}</div>` : ''}
        </div>
      </div>
    `;
  }
  
  function renderEmptyState(message: string): string {
    return `<div class="empty-state"><p>${message}</p></div>`;
  }
  
  function attachCheckCardListeners() {
    document.querySelectorAll('.check-header').forEach(header => {
      header.addEventListener('click', () => {
        const card = header.parentElement!;
        card.classList.toggle('expanded');
        const isExpanded = card.classList.contains('expanded');
        header.setAttribute('aria-expanded', String(isExpanded));
      });
      
      header.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          (header as HTMLElement).click();
        }
      });
    });
  }
</script>

<style>
  .main {
    flex: 1;
    padding-top: var(--space-20);
    padding-bottom: var(--space-10);
  }
  
  /* Hero */
  .hero {
    max-width: var(--container-narrow);
    margin-inline: auto;
  }
  
  .hero-content {
    margin-bottom: var(--space-12);
  }
  
  .hero-title {
    font-size: clamp(var(--text-3xl), 6vw, var(--text-5xl));
    font-weight: 500;
    letter-spacing: -0.03em;
    margin-bottom: var(--space-4);
    color: var(--color-text);
  }
  
  .hero-subtitle {
    font-size: var(--text-lg);
    color: var(--color-text-muted);
    max-width: 400px;
  }
  
  /* Report Section */
  .report-section {
    max-width: var(--container-max);
    margin-inline: auto;
  }
  
  .hidden {
    display: none !important;
  }
</style>
